<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ma bulle de recommandation – Créateur d'Arbre</title>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: Verdana, sans-serif;
      background: linear-gradient(to bottom, #5bc0eb, #20639b);
      height: 100vh; overflow: hidden;
      position: relative; animation: fadeIn 0.5s ease forwards;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    @keyframes fadeOut{from{opacity:1}to{opacity:0}}
    .fade-out{animation:fadeOut .5s ease forwards}
    .nav-bubble { 
      position: absolute; top: 1rem;
      width: 30px; height: 30px; background: rgba(255,255,255,0.2);
      border-radius: 50%; display: flex; align-items: center;
      justify-content: center; cursor: pointer;
      backdrop-filter: blur(6px); transition: background 0.2s;
      z-index: 20; color: #fff; font-size: 1rem;
    }
    .nav-bubble:hover { background: rgba(255,255,255,0.3); }
    .nav-left { right: 70px; }
    .nav-right { right: 20px; }

    #container {
      position: absolute;
      top: 4rem; bottom: 2rem;
      left: 2rem; right: 2rem;
      background: #f9fcff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      overflow: hidden;
    }

    #toolbar {
      display: flex; align-items: center;
      padding: 0.5rem;
      background: #fff;
      border-bottom: 1px solid #ccc;
    }
    .shape-btn {
      width: 40px; height: 40px;
      margin-right: 12px;
      border: none; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .decision-shape {
      background: #4caf50;
      clip-path: polygon(50% 0%,100% 50%,50% 100%,0% 50%);
    }
    .leaf-shape {
      background: #2196f3;
      border-radius: 8px;
    }
    #toolbar button:not(.shape-btn) {
      margin-left: auto;
      background: #cecece;
      border: none;
      color: #000;
      font-size: 1rem;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
    }
    #toolbar button:not(.shape-btn):hover {
      background: #484848; color: #fff;
    }

    #cy {
      width: 100%; height: calc(100% - 50px);
      position: relative;
    }

    #trash {
      position: absolute; bottom: 1rem; right: 1rem;
      width: 40px; height: 40px;
      background: url('https://img.icons8.com/material-outlined/48/333333/trash.png') no-repeat center;
      background-size: 24px 24px;
      opacity: 0.6; transition: opacity 0.2s;
      z-index: 5; pointer-events: none;
    }
    #trash.hovered {
      opacity: 1;
      filter: drop-shadow(0 0 5px red);
    }

    #labelEditor {
      position: absolute; display: none;
      z-index: 9; border: 1px solid #aaa;
      padding: 4px; font-size: 14px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      background: #fff;
    }

    .bubble-floating {
      position: absolute; border-radius: 50%;
      background: rgba(255,255,255,0.1);
      animation: floatUp 30s linear infinite;
      pointer-events: none; backdrop-filter: blur(8px);
      z-index: -1;
    }
    @keyframes floatUp {
      0% { bottom: -100px; transform: translateX(0); }
      100% { bottom: 110%; transform: translateX(50px); }
    }
  </style>
  <script src="https://unpkg.com/cytoscape@3.32.1/dist/cytoscape.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
</head>
<body>
  <!-- Navigation -->
  <div class="nav-bubble nav-left" onclick="navigate('page2.html')">◀</div>
  <div class="nav-bubble nav-right" onclick="navigate('page4.html')">▶</div>

  <div id="container">
    <div id="toolbar">
      <button class="shape-btn decision-shape" id="addDecision" title="Ajouter un nœud de décision"></button>
      <button class="shape-btn leaf-shape" id="addLeaf" title="Ajouter un nœud résultat"></button>
      
      
    </div>
    <div id="cy"></div>
    <input id="labelEditor" type="text" />
    <div id="trash" title="Glissez ici pour supprimer"></div>

  </div>

  <!-- Background bubbles -->
  <div class="bubble-floating" style="left:10%; width:80px; height:80px; animation-delay:1s;"></div>
  <div class="bubble-floating" style="left:30%; width:60px; height:60px; animation-delay:5s;"></div>
  <div class="bubble-floating" style="left:50%; width:100px; height:100px; animation-delay:3s;"></div>
  <div class="bubble-floating" style="left:70%; width:50px; height:50px; animation-delay:7s;"></div>
  <div class="bubble-floating" style="left:90%; width:80px; height:80px; animation-delay:4s;"></div>

<script>
    const LOG = (...args) => { try { console.log('[page3]', ...args); } catch (_) {} };
    function navigate(url) {
      LOG('navigate', url);
      saveState();
      document.body.classList.add('fade-out');
      document.body.addEventListener('animationend', () => window.location.href = url, { once: true });
    }

    // --- Graph state (session only, no URL) ---
    const GRAPH_KEY = 'graphSessionV1';
    let isRestoring = false;
    let nextNodeId = 0, nextEdgeId = 0;

    // Keep only the fields Cytoscape needs and normalize classes/positions
    function cleanElement(ele) {
      if (!ele || !ele.group || !ele.data) return null;
      const base = { group: ele.group, data: { ...ele.data } };
      const cls = ele.classes || ele.data.classes;
      if (cls && String(cls).trim()) {
        base.classes = Array.isArray(cls) ? cls.join(' ') : String(cls);
      }
      if (ele.group === 'nodes') {
        const pos = ele.position;
        if (pos && Number.isFinite(pos.x) && Number.isFinite(pos.y)) {
          base.position = { x: Number(pos.x), y: Number(pos.y) };
        }
      }
      return base;
    }

    // Accept either a raw array or a {nodes,edges} shape (old snapshots)
    function normalizeSnapshotShape(raw) {
      if (!raw) return [];
      if (Array.isArray(raw)) return raw;
      if (raw.nodes || raw.edges) {
        return [...(raw.nodes || []), ...(raw.edges || [])];
      }
      return [];
    }

    function readSnapshot() {
      const raw = sessionStorage.getItem(GRAPH_KEY);
      LOG('readSnapshot raw exists', !!raw);
      if (!raw) return [];

      const tryParse = txt => normalizeSnapshotShape(JSON.parse(txt));

      try {
        const parsed = tryParse(raw);
        if (parsed.length) return parsed;
      } catch (e) { LOG('readSnapshot json fail', e); }

      try {
        const txt = LZString.decompressFromEncodedURIComponent(raw);
        if (txt) {
          const parsed = tryParse(txt);
          if (parsed.length) return parsed;
        }
      } catch (e) { LOG('readSnapshot lz fail', e); }

      return [];
    }

    function prepareElements(list) {
      const cleaned = list.map(cleanElement).filter(Boolean);
      const nodes = [];
      const edges = [];
      const nodeIds = new Set();

      // Simple grid fallback when positions are missing
      let col = 0, row = 0;
      const stepX = 240, stepY = 140, startX = 140, startY = 160, maxCols = 3;

      cleaned.forEach(ele => {
        if (ele.group !== 'nodes') return;
        const id = String(ele.data.id || ele.data.name || 'n' + nodes.length);
        if (nodeIds.has(id)) return;
        const node = { ...ele, data: { ...ele.data, id } };
        if (!node.position) {
          node.position = { x: startX + col * stepX, y: startY + row * stepY };
          col = (col + 1) % maxCols;
          if (col === 0) row++;
        }
        nodeIds.add(id);
        nodes.push(node);
      });

      cleaned.forEach(ele => {
        if (ele.group !== 'edges') return;
        const source = ele.data.source;
        const target = ele.data.target;
        if (!source || !target) return;
        const src = String(source), tgt = String(target);
        if (!nodeIds.has(src) || !nodeIds.has(tgt)) return;
        const id = ele.data.id ? String(ele.data.id) : 'e' + edges.length;
        edges.push({ ...ele, data: { ...ele.data, id, source: src, target: tgt } });
      });

      return { nodes, edges };
    }

    function resyncCounters() {
      const nodeNums = cy.nodes().map(n => parseInt((n.id().match(/\d+/) || [])[0], 10)).filter(Number.isFinite);
      const edgeNums = cy.edges().map(e => parseInt((e.id().match(/\d+/) || [])[0], 10)).filter(Number.isFinite);
      nextNodeId = nodeNums.length ? Math.max(...nodeNums) + 1 : 0;
      nextEdgeId = edgeNums.length ? Math.max(...edgeNums) + 1 : 0;
    }

    function saveState() {
      if (isRestoring) return;
      const snapshot = cy.elements().jsons().map(cleanElement).filter(Boolean);
      try {
        sessionStorage.setItem(GRAPH_KEY, JSON.stringify(snapshot));
      } catch (e) {
        console.warn('saveState failed', e);
      }
      LOG('saveState', { nodes: cy.nodes().length, edges: cy.edges().length });
    }

    function restoreGraphFromSnapshot(snapshotList) {
      const list = Array.isArray(snapshotList) ? snapshotList : readSnapshot();
      const { nodes, edges } = prepareElements(list);
      LOG('restoreGraphFromSnapshot prepared', { nodes: nodes.length, edges: edges.length });

      isRestoring = true;
      cy.elements().remove();
      if (nodes.length) cy.add(nodes);

      const finalize = () => {
        resyncCounters();
        requestAnimationFrame(() => {
          cy.resize();
          isRestoring = false;
          // Persist normalized snapshot so future loads are consistent
          saveState();
        });
      };

      if (!edges.length) {
        finalize();
        return;
      }

      // Load edges on the next tick to ensure node registry is complete
      requestAnimationFrame(() => {
        cy.add(edges);
        finalize();
      });
    }

    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: [],
      style: [
        { selector: 'node', style: {
            'label': 'data(label)',
            'text-valign': 'center', 'text-halign': 'center',
            'color': '#fff', 'width': 'label', 'height': 50,
            'background-color': '#666'
          }
        },
        { selector: '.decision', style: { 'shape': 'diamond', 'background-color': '#4CAF50', 'padding': '30px' } },
        { selector: '.leaf', style: { 'shape': 'roundrectangle', 'background-color': '#2196F3', 'padding': '10px' } },
        { selector: 'edge', style: {
            'width': 2, 'line-color': '#000',
            'target-arrow-shape': 'triangle', 'target-arrow-color': '#000',
            'arrow-scale': 1.2, 'curve-style': 'bezier',
            'label': 'data(label)', 'text-margin-y': -10,
            'text-background-opacity': 1, 'text-background-color': '#fff',
            'text-background-shape': 'roundrectangle', 'text-background-padding': 2,
            'font-size': 12, 'text-rotation': 'autorotate'
          }
        }
      ],
      layout: { name: 'preset' }
    });
    const cyEl = document.getElementById('cy');

    if (window.ResizeObserver) {
      new ResizeObserver(() => cy.resize()).observe(cyEl);
    }
    window.addEventListener('resize', () => cy.resize());

    // Auto-save on changes
    cy.on('add remove data position', saveState);

    // Initial Load
    const initialSnapshot = readSnapshot();
    LOG('initial snapshot', { count: initialSnapshot.length, sample: initialSnapshot.slice(0,3) });
    if(initialSnapshot.length) restoreGraphFromSnapshot(initialSnapshot);
    else saveState();

    function addNode(type) {
      const id = (type==='decision'? 'd' : 'l') + nextNodeId++;
      cy.add({ 
        group: 'nodes', 
        data: { id, label: type==='decision'? 'Décision':'Résultat' }, 
        classes: type,
        position: { x:100+Math.random()*400, y:100+Math.random()*300 } 
      });
      // Note: 'add' event triggers saveState automatically
    }
    document.getElementById('addDecision').onclick = () => addNode('decision');
    document.getElementById('addLeaf').onclick     = () => addNode('leaf');
    

    // --- SVG preview line ---
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('style', 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10');
    const defs = document.createElementNS(svgNS, 'defs');
    const marker = document.createElementNS(svgNS, 'marker');
    marker.setAttribute('id','arrowHead');
    marker.setAttribute('markerWidth','6');
    marker.setAttribute('markerHeight','6');
    marker.setAttribute('refX','0');
    marker.setAttribute('refY','3');
    marker.setAttribute('orient','auto');
    const path = document.createElementNS(svgNS,'path');
    path.setAttribute('d','M0,0 L0,6 L6,3 z');
    path.setAttribute('fill','#000');
    marker.appendChild(path);
    defs.appendChild(marker);
    svg.appendChild(defs);
    const line = document.createElementNS(svgNS,'line');
    line.setAttribute('id','previewLine');
    line.setAttribute('stroke','#000');
    line.setAttribute('stroke-width','2');
    line.setAttribute('marker-end','url(#arrowHead)');
    line.setAttribute('visibility','hidden');
    svg.appendChild(line);
    cy.container().appendChild(svg);

    // --- Linking logic (right-drag) ---
    let linkOrigin = null, linkTarget = null, didDrag = false;
    cy.on('cxttapstart','node', evt => {
      linkOrigin = evt.target; didDrag = false; linkTarget = null;
      const p = linkOrigin.renderedPosition();
      line.setAttribute('x1',p.x);
      line.setAttribute('y1',p.y);
      line.setAttribute('x2',p.x);
      line.setAttribute('y2',p.y);
      line.setAttribute('visibility','visible');
    });
    cy.on('cxtdrag', evt => {
      if (!linkOrigin) return;
      didDrag = true;
      const rp = evt.renderedPosition;
      line.setAttribute('x2',rp.x);
      line.setAttribute('y2',rp.y);
    });
    cy.on('cxtdragover','node', evt => {
      if (didDrag && evt.target.id()!==linkOrigin.id()) {
        linkTarget = evt.target;
      }
    });
    cy.on('cxtdragout','node', evt => {
      if (linkTarget && evt.target.id()===linkTarget.id()) {
        linkTarget = null;
      }
    });
    cy.on('cxttapend', () => {
      line.setAttribute('visibility','hidden');
      if (didDrag && linkOrigin && linkTarget && linkOrigin.id()!==linkTarget.id()) {
        const cnt = cy.edges().filter(e => e.source().id()===linkOrigin.id()).length;
        const lbl = cnt===0 ? 'oui' : cnt===1 ? 'non' : '';
        
        // Add edge
        cy.add({
          group:'edges',
          data:{
            id:'e'+nextEdgeId,
            source:linkOrigin.id(),
            target:linkTarget.id(),
            label: lbl
          }
        });
        nextEdgeId++;
        // NOTE: removed explicit saveState() here because cy.add triggers the 'add' event, 
        // which calls saveState() automatically. Double-saving caused race conditions.
      }
      linkOrigin = linkTarget = null;
      didDrag = false;
    });

    // Inline editing
    const labelEditor = document.getElementById('labelEditor'); let editing = null;
    function showEditor(ele,pos,text){ editing=ele;
      labelEditor.value = text||'';
      labelEditor.style.left = pos.x + 'px'; labelEditor.style.top = pos.y + 'px';
      labelEditor.style.display = 'block'; labelEditor.focus(); labelEditor.select();
    }
    cy.on('dbltap','node', evt => showEditor(evt.target, evt.target.renderedPosition(), evt.target.data('label')));
    cy.on('dbltap','edge', evt => {
      const e = evt.target, mid=e.midpoint(), z=cy.zoom(), pan=cy.pan();
      const pos={ x: mid.x*z+pan.x, y: mid.y*z+pan.y };
      showEditor(e,pos,e.data('label'));
    });
    labelEditor.addEventListener('keydown', e => { if(e.key==='Enter') commit(); else if(e.key==='Escape') cancel(); });
    labelEditor.addEventListener('blur', commit);
    function commit(){ if(editing && labelEditor.value.trim()){ editing.data('label',labelEditor.value.trim()); saveState(); }
      labelEditor.style.display='none'; editing=null; }
    function cancel(){ labelEditor.style.display='none'; editing=null; }

    // Delete via trash
    let grab=null;
    cy.on('grab','node', evt => grab=evt.target);
    cy.on('drag', evt => {
      if(!grab) return;
      const trash = document.getElementById('trash');
      const rect= trash.getBoundingClientRect();
      const cr=document.getElementById('cy').getBoundingClientRect();
      const p=evt.renderedPosition; const ax=cr.left+p.x, ay=cr.top+p.y;
      trash.classList[ ax>=rect.left&&ax<=rect.right&&ay>=rect.top&&ay<=rect.bottom? 'add':'remove']('hovered');
    });
    cy.on('free','node', evt => {
      if(!grab) return;
      const trash = document.getElementById('trash');
      const rect= trash.getBoundingClientRect();
      const cr=document.getElementById('cy').getBoundingClientRect();
      const p=evt.renderedPosition; const ax=cr.left+p.x, ay=cr.top+p.y;
      if(ax>=rect.left&&ax<=rect.right&&ay>=rect.top&&ay<=rect.bottom) {
        grab.connectedEdges().remove(); grab.remove();
        // saveState() triggers automatically on 'remove'
      }
      trash.classList.remove('hovered'); grab=null;
    });
  </script>
</body>
</html>
